# Copyright 2021 Free Internals.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


msg_dex_file_magic1 = The constant array/string DEX_FILE_MAGIC is the list of bytes that must appear at the beginning of a .dex file in order for it to be recognized as such. The value intentionally contains a newline ("\n" or 0x0a) and a null byte ("\0" or 0x00) in order to help in the detection of certain forms of corruption.
msg_dex_file_magic2 = The value also encodes a format version number as three decimal digits, which is expected to increase monotonically over time as the format evolves.

msg_header_item_checksum = adler32 checksum of the rest of the file (everything but magic and this field); used to detect file corruption
msg_header_item_signature = SHA-1 signature (hash) of the rest of the file (everything but magic, checksum, and this field); used to uniquely identify files 
msg_header_item_file_size = size of the entire file (including the header), in bytes 
msg_header_item_header_size = size of the header (this entire section), in bytes. This allows for at least a limited amount of backwards/forwards compatibility without invalidating the format.
msg_header_item_endian_tag = endianness tag. See discussion above under "ENDIAN_CONSTANT and REVERSE_ENDIAN_CONSTANT" for more details.
msg_header_item_link_size = size of the link section, or 0 if this file isn't statically linked
msg_header_item_link_off = offset from the start of the file to the link section, or 0 if link_size == 0. The offset, if non-zero, should be to an offset into the link_data section. The format of the data pointed at is left unspecified by this document; this header field (and the previous) are left as hooks for use by runtime implementations.
msg_header_item_map_off = offset from the start of the file to the map item. The offset, which must be non-zero, should be to an offset into the data section, and the data should be in the format specified by "map_list" below. 
msg_header_item_string_ids_size = count of strings in the string identifiers list
msg_header_item_string_ids_off = offset from the start of the file to the string identifiers list, or 0 if string_ids_size == 0 (admittedly a strange edge case). The offset, if non-zero, should be to the start of the string_ids section. 
msg_header_item_type_ids_size = count of elements in the type identifiers list, at most 65535
msg_header_item_type_ids_off = offset from the start of the file to the type identifiers list, or 0 if type_ids_size == 0 (admittedly a strange edge case). The offset, if non-zero, should be to the start of the type_ids section. 
msg_header_item_proto_ids_size = count of elements in the prototype identifiers list, at most 65535
msg_header_item_proto_ids_off = offset from the start of the file to the prototype identifiers list, or 0 if proto_ids_size == 0 (admittedly a strange edge case). The offset, if non-zero, should be to the start of the proto_ids section. 
msg_header_item_field_ids_size = count of elements in the field identifiers list
msg_header_item_field_ids_off = offset from the start of the file to the field identifiers list, or 0 if field_ids_size == 0. The offset, if non-zero, should be to the start of the field_ids section.
msg_header_item_method_ids_size = count of elements in the method identifiers list
msg_header_item_method_ids_off = offset from the start of the file to the method identifiers list, or 0 if method_ids_size == 0. The offset, if non-zero, should be to the start of the method_ids section.
msg_header_item_class_defs_size = count of elements in the class definitions list
msg_header_item_class_defs_off = offset from the start of the file to the class definitions list, or 0 if class_defs_size == 0 (admittedly a strange edge case). The offset, if non-zero, should be to the start of the class_defs section. 
msg_header_item_data_size = Size of data section in bytes. Must be an even multiple of sizeof(uint).
msg_header_item_data_off = offset from the start of the file to the start of the data section. 

msg_string_id_item__string_data_off = offset from the start of the file to the string data for this item. The offset should be to a location in the data section, and the data should be in the format specified by "string_data_item" below. There is no alignment requirement for the offset.
msg_string_data_item = Appears in the data section of the ELF file.
msg_string_data_item__utf16_size = size of this string, in UTF-16 code units (which is the "string length" in many systems). That is, this is the decoded length of the string. (The encoded length is implied by the position of the 0 byte.)
msg_string_data_item__data = a series of MUTF-8 code units (a.k.a. octets, a.k.a. bytes) followed by a byte of value 0. See "MUTF-8 (Modified UTF-8) Encoding" above for details and discussion about the data format.

msg_type_id_item__descriptor_idx = index into the string_ids list for the descriptor string of this type. The string must conform to the syntax for TypeDescriptor, defined above.

msg_proto_id_item__shorty_idx =index into the string_ids list for the short-form descriptor string of this prototype. The string must conform to the syntax for ShortyDescriptor, defined above, and must correspond to the return type and parameters of this item.
msg_proto_id_item__return_type_idx = index into the type_ids list for the return type of this prototype
msg_proto_id_item__parameters_off = offset from the start of the file to the list of parameter types for this prototype, or 0 if this prototype has no parameters. This offset, if non-zero, should be in the data section, and the data there should be in the format specified by "type_list" below. Additionally, there should be no reference to the type void in the list.

msg_field_id_item__class_idx = index into the type_ids list for the definer of this field. This must be a class type, and not an array or primitive type. 
msg_field_id_item__type_idx = index into the type_ids list for the type of this field
msg_field_id_item__name_idx = index into the string_ids list for the name of this field. The string must conform to the syntax for MemberName, defined above.

msg_method_id_item__class_idx = index into the type_ids list for the definer of this method. This must be a class or array type, and not a primitive type.
msg_method_id_item__proto_idx = index into the proto_ids list for the prototype of this method
msg_method_id_item__name_idx = index into the string_ids list for the name of this method. The string must conform to the syntax for MemberName, defined above.

msg_class_def_item__class_idx = index into the type_ids list for this class. This must be a class type, and not an array or primitive type. 
msg_class_def_item__access_flags = access flags for the class (public, final, etc.). See "access_flags Definitions" for details. 
msg_class_def_item__superclass_idx = index into the type_ids list for the superclass, or the constant value NO_INDEX if this class has no superclass (i.e., it is a root class such as Object). If present, this must be a class type, and not an array or primitive type.
msg_class_def_item__interfaces_off = offset from the start of the file to the list of interfaces, or 0 if there are none. This offset should be in the data section, and the data there should be in the format specified by "type_list" below. Each of the elements of the list must be a class type (not an array or primitive type), and there must not be any duplicates.
msg_class_def_item__source_file_idx = index into the string_ids list for the name of the file containing the original source for (at least most of) this class, or the special value NO_INDEX to represent a lack of this information. The debug_info_item of any given method may override this source file, but the expectation is that most classes will only come from one source file.
msg_class_def_item__annotations_off = offset from the start of the file to the annotations structure for this class, or 0 if there are no annotations on this class. This offset, if non-zero, should be in the data section, and the data there should be in the format specified by "annotations_directory_item" below, with all items referring to this class as the definer.
msg_class_def_item__class_data_off = offset from the start of the file to the associated class data for this item, or 0 if there is no class data for this class. (This may be the case, for example, if this class is a marker interface.) The offset, if non-zero, should be in the data section, and the data there should be in the format specified by "class_data_item" below, with all items referring to this class as the definer.
msg_class_def_item__static_values_off = offset from the start of the file to the list of initial values for static fields, or 0 if there are none (and all static fields are to be initialized with 0 or null). This offset should be in the data section, and the data there should be in the format specified by "encoded_array_item" below. The size of the array must be no larger than the number of static fields declared by this class, and the elements correspond to the static fields in the same order as declared in the corresponding field_list. The type of each array element must match the declared type of its corresponding field. If there are fewer elements in the array than there are static fields, then the leftover fields are initialized with a type-appropriate 0 or null.

msg_call_site_id_item__call_site_off = offset from the start of the file to call site definition. The offset should be in the data section, and the data there should be in the format specified by "call_site_item" below.

msg_method_handle_item__method_handle_type = type of the method handle; see table below
msg_method_handle_item__field_or_method_id = Field or method id depending on whether the method handle type is an accessor or a method invoker

